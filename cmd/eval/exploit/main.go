package main

import (
	"flag"
	"log/slog"
	"sync"
	"time"

	"github.com/filevich/truco-mccfr-ai/bot"
	"github.com/filevich/truco-mccfr-ai/cfr"
	"github.com/filevich/truco-mccfr-ai/eval"
	"github.com/filevich/truco-mccfr-ai/eval/dataset"
	"github.com/filevich/truco-mccfr-ai/utils"
)

// flags
var (
	numPlayersPtr   = flag.Int("p", 2, "Number of players")
	hashPtr         = flag.String("hash", "sha160", "Hash fn")
	infoPtr         = flag.String("info", "InfosetRondaBase", "Infoset Impl")
	absPtr          = flag.String("abs", "a3", "Abstraction")
	threadsPtr      = flag.Int("threads", 1, "Threads")
	saveDirPtr      = flag.String("dir", "/tmp/", "Save directory")
	tinyEvalPtr     = flag.Int("eval", 1_000, "Progress eval length")
	runPtr          = flag.String("run", "119h", "Total run time")
	prunningPtr     = flag.String("prunning", "72h", "Start prunning after")
	prunningProbPtr = flag.Float64("prunning_prob", 0.1, "Pruning prob")
	saveEveryPtr    = flag.String("save_every", "", "Saving interval (empty for NEVER)")
	evalEveryPtr    = flag.String("eval_every", "1m", "Eval interval")
	silentPtr       = flag.Bool("silent", true, "Silent model")
	fullySilentPtr  = flag.Bool("fully_silent", true, "Fully silent model")
	prefixPtr       = flag.String("prefix", "exploit_", "Model prefix")
	datasetPtr      = flag.String("dataset", "t1k22.json", "Dataset file")
	exploitedPtr    = flag.String("exploited", "random", "Bot to exploit (random, simple, simplex)")
)

func init() {
	flag.Parse()
	slog.Info(
		"START",
		"numPlayers", *numPlayersPtr,
		"hash", *hashPtr,
		"info", *infoPtr,
		"abs", *absPtr,
		"threads", *threadsPtr,
		"saveDir", *saveDirPtr,
		"tinyEval", *tinyEvalPtr,
		"run", *runPtr,
		"prunning", *prunningPtr,
		"prunningProb", *prunningProbPtr,
		"saveEvery", *saveEveryPtr,
		"evalEvery", *evalEveryPtr,
		"silent", *silentPtr,
		"fullySilent", *fullySilentPtr,
		"prefix", *prefixPtr,
		"dataset", *datasetPtr,
		"exploited", *exploitedPtr,
	)
}

var (
	ds dataset.Dataset
)

func main() {
	var (
		saveDir          = *saveDirPtr
		threads          = *threadsPtr
		numPlayers       = *numPlayersPtr
		tinyEval         = *tinyEvalPtr
		totalRunningTime time.Duration
		prunningTreshold time.Duration
		saveEvery        time.Duration
		evalEvery        time.Duration
		err              error
	)

	if totalRunningTime, err = time.ParseDuration(*runPtr); err != nil {
		panic(err)
	}

	if *prunningPtr == "" {
		prunningTreshold = cfr.NEVER
	} else {
		prunningTreshold, err = time.ParseDuration(*prunningPtr)
		if err != nil {
			panic(err)
		}
	}

	if *saveEveryPtr == "" {
		saveEvery = cfr.NEVER
	} else {
		saveEvery, err = time.ParseDuration(*saveEveryPtr)
		if err != nil {
			panic(err)
		}
	}

	if evalEvery, err = time.ParseDuration(*evalEveryPtr); err != nil {
		panic(err)
	}

	// Load dataset
	slog.Info("LOADING_DATASET", "file", *datasetPtr)
	tic := time.Now()
	ds = dataset.LoadDataset(*datasetPtr)
	slog.Info("FINISHED_LOADING_DATASET", "delta", time.Since(tic))

	// Select bot to exploit based on flag
	var exploited cfr.Agent
	switch *exploitedPtr {
	case "random":
		exploited = &bot.Random{}
	case "simple":
		exploited = &bot.Simple{}
	case "simplex":
		exploited = &bot.SimpleX{}
	default:
		panic("Invalid exploited bot: " + *exploitedPtr + ". Valid options: random, simple, simplex")
	}

	slog.Info("EXPLOITING", "agent", exploited.UID())

	exploited.Initialize()
	trainer := cfr.NewTrainer(
		cfr.BR_T,
		numPlayers,
		*hashPtr,
		*infoPtr,
		*absPtr,
	)

	evaluator := func() {
		exploiter := &cfr.BotCFR{
			ID:    trainer.String(),
			Model: trainer,
		}
		rr := eval.PlayMultipleDoubleGames(exploiter, []cfr.Agent{exploited}, numPlayers, ds[:tinyEval])
		infos := trainer.CountInfosets()

		var delta time.Duration = 0

		// general progress info
		slog.Info("REPORT", "infos", infos, "iters", trainer.Get_t())

		for _, r := range rr {
			delta += r.Delta
			u, l := r.WaldInterval(true)
			slog.Info(
				"RESULTS",
				"opponent", exploited.UID(),
				"wr", r.WP(),
				"wald_interval_upper", u,
				"wald_interval_lower", l,
				"di", r.Dumbo1,
			)
		}
		slog.Info("EVAL_DONE", "delta", delta)

		heapAlloc, totalAlloc, sys := utils.GetMemUsageMiB()
		rss := utils.GetMemUsageOSMiB()
		slog.Info(
			"MEMORY",
			"heapAlloc", heapAlloc,
			"totalAlloc", totalAlloc,
			"sys", sys,
			"rss", rss,
		)
	}

	trainer.Train(
		&cfr.ProfileTime{
			Exploiting:       exploited,
			TotalRunningTime: totalRunningTime,
			PrunningTreshold: prunningTreshold,
			PrunningProb:     float32(*prunningProbPtr),
			// multi
			Threads: threads,
			Mu:      &sync.Mutex{},
			// io
			SaveEvery:   saveEvery,
			Silent:      *silentPtr,
			FullySilent: *fullySilentPtr,
			SaveDir:     saveDir,
			SavePrefix:  *prefixPtr,
			// post save
			EvalEvery: evalEvery,
			Evaluator: evaluator,
			PostSave:  nil,
		},
	)
}
